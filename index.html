<!DOCTYPE html>
<html>

<head>
	<meta name="viewport" content="width=device-width,initial-scale=1.0">
	<meta charset="utf-8">
	<title>Xchat | Xapp.com</title>
</head>

<body>
	<ul id="messages"></ul>
	<form id="form" action="">
		<input id="input" autocomplete="off" />
		<button>Send</button>
	</form>

	<script src="https://cdn.socket.io/4.8.1/socket.io.min.js"></script>
	<!-- <script src="/socket.io/socket.io.js"></script> -->
	<!-- <script src="node_modules/socket.io/client-dist/socket.io.js"></script> -->

	<script>
		// Создаем сокет чата на стороне клиента для файла index.html
		const socket = io(
			// 1 параметр - оригинальный адрес сайта на котором запускается чат
			window.location.origin,
			
			// 2 параметр - объект из разных свойств. В нашем случае передаем свойство "path" которое указывает дирекотрию/папку сайта в которой запускается файл index.html
			// !!! - к дериктории/папке добавляем строку "socket.io" (отсутствие этой строки не позволяло запускать чат на удаленном сервере)
			{
				path: window.location.pathname + 'socket.io'
			}
		);

		// Создаем константы для работы с формой, полем ввода сообщения, списком сообщений
		const form = document.getElementById('form');
		const input = document.getElementById('input');
		const messages = document.getElementById('messages');
		
		// !!! Для временного решения проблемы с дублированием сообщений из базы данных во вермя перезагрузки гл.файла создаем переменную areDbMessage  перед подключением к сокету. Есть другое решение данной проблемы - более правильное, но более сложное в реализации. Пока что такое решение - быстрое и простое)))
		let areDbMessages = false;
		// Со стороны клиента подключаемся к событию "db_messages" для получения всех сообщений из БД
		socket.on('db_messages', (dbMessages) => {
			// !!! Если переменна areDbMessages == false, то полученные сообщеия из БД записанные в dbMessages показываем на странице
			if(areDbMessages === false){
				// Так как получаем массив сообщений, то нужно пропустить его через цикл, чтобы получить каждое сообщение в отдельности
				dbMessages.forEach(dbMsg => {
					// !!! Дублированный код ниже => socket.on('chat_message...
					const item = document.createElement('li');
					// каждое сообщение из БД это объект с названием колонок из БД. Т.к. получаем колонку "content" то это будет название свойства объекта сообщения, чтобы получить само сообщение
					item.textContent = dbMsg.content;
					messages.appendChild(item);
					window.scrollTo(0, document.body.scrollHeight);
				});
			}
			// !!! После того как показали на странице сообщения из БД, изменяем переменную areDbMessages = true
			// В случае перезапуска гл.файла index.js на сервере файл index.html остается без изменений и переменная areDbMessages продолжает быть true. А значит при перезапуске гл.файлa index.js, который отправляет сообщения из БД в index.html условие if не исполнится, т.к. areDbMessages == true и значит не показываем в index.html полученные сообщения из БД. Хотя код из index.js отправляет все сообщения повторно для index.html и в dbMessages каждый раз присылаются сообщения при каждом перезапуске index.js. Тут просто блокируем повтороное отбражение сообщений из БД которые уже показаны на странце. Это только для режима разработки. Позже надо будет разрешить данную проблему иначе, более профессионально, не присылая со строноы сервера сообщений, котороые не нужны для клиента)))
			areDbMessages = true;
		})

		// Подключаемся к событию отправки форм
		form.addEventListener('submit', (e) => {
			// отключаем событие по умолчанию
			e.preventDefault();
			// проверяем поле формы
			if (input.value) {
				// если поле формы не пустое
				// отправляем сообщение для события чата под именем "chat_message"(имя может быть любое)
				socket.emit('chat_message', input.value);
				// после отправки сообщения чистим поле для нового сообщения
				input.value = '';
			}
		});
		
		// подключаемся к событию чата chat_message
		// для получаения сообщеий от данного события
		socket.on('chat_message', (msg) => {
			// создаем элемент списка
			const item = document.createElement('li');
			// добавляем сообщение от сокета в элемент списка
			item.textContent = msg;
			// добавляем новый элемент списка в список <ul>
			messages.appendChild(item);
			// скролим экран к последнему сообщению если <body> больше чем высота экрана
			window.scrollTo(0, document.body.scrollHeight);
		});

		socket.on("connect_error", (err) => {
			console.log(err.message);
			console.log(err.description);
			console.log(err.context);
  		});
		
	</script>
</body>

</html>